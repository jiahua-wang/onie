#!/bin/sh

#  Copyright (C) 2013,2014,2015,2018 Curt Brune <curt@cumulusnetworks.com>
#  Copyright (C) 2014 Matt Peterson <matt-github@peterson.org>
#  Copyright (C) 2014,2015,2016,2017 david_yang <david_yang@accton.com>
#
#  SPDX-License-Identifier:     GPL-2.0

. /lib/onie/functions
syslog_tag=onie-exec

install_result="/var/run/install.rc"
default_signature="/var/tmp/installer.sign"
ONIE_IMAGE_GUID="216e9675-be17-46c7-aa71-e525eac83bd2"
CERT_TYPE_PKCS7_GUID="4aafd29d-68df-49ee-8aa9-347d375665a7"
iib_size=48
guid_size=16
iib_len_offset=16
iib_len_size=8

# If the NOS install returns success then reboot.
finish_nos_install()
{
    local result="$1"
    local URL="$2"
    local update_image="$3"

    if [ $result -eq 0 ] ; then
        log_console_msg "NOS install successful: $URL"
        log_console_msg "Rebooting..."
        reboot && return 0
    fi
    return 1
}

finish_update_install()
{
    local result="$1"
    local URL="$2"
    local update_image="$3"

    if [ $result -eq 0 ] ; then
        log_console_msg "Firmware update install successful: $URL"
        if [ -x /tmp/reboot-cmd ] ; then
            log_console_msg "Calling update supplied reboot-cmd..."
            /tmp/reboot-cmd
            sleep 10
        else
            log_console_msg "Rebooting..."
            reboot && return 0
        fi
    fi
    return 1
}

# Allow architectures to override finish_nos_install() and
# finish_update_install().
[ -r /lib/onie/exec-installer-arch ] && . /lib/onie/exec-installer-arch

check_installer()
{
    # Check whether the image type passed by 'onie-nos-install',
    # 'onie-self-update' or 'discover' is compatible with the current
    # boot reason.
    local image_type="$1"

    case $onie_boot_reason in
        update | embed)
            [ "$image_type" = "$onie_image_type_update" ] && return 0
            log_failure_msg "ONIE Update: Invalid ONIE update image format."
            ;;
        rescue)
            # Allow to run either NOS installer or ONIE updater at the situation
            return 0
            ;;
        install)
            [ "$image_type" = "$onie_image_type_nos" ] && return 0
            log_failure_msg "NOS Installer: Expecting install image, but found ONIE update image format."
            ;;
        *)
            log_failure_msg "Unknown boot reason: ${onie_boot_reason}"
            ;;
    esac

    return 1
}

check_secure_boot()
{
    # Check if the SecureBoot is enabled on the system
	local sb_path sm_file sb sm

	sb_path=$(find /sys/firmware/efi/efivars -name SecureBoot-* 2>/dev/null)
	sm_path=$(find /sys/firmware/efi/efivars -name SetupMode-* 2>/dev/null)

	if [ -f "$sb_path" ] && [ -f "$sm_path" ]; then
		sb=$(hexdump -v -e '/1 "%d\ "' $sb_path|cut -d' ' -f 5)
		sm=$(hexdump -v -e '/1 "%d\ "' $sm_path|cut -d' ' -f 5)

		if [ "$sb" = "1" ] && [ "$sm" = "0" ]; then
			return 0
		fi
	fi

    return 1
}

export_efi_certs() {
    dest=$1

    mkdir -p $dest/db
    mkdir -p $dest/dbx

    old_dir=$PWD

    cd $dest/db
    mokutil -x --db  > /dev/null 2>&1
    mokutil -x --pk  > /dev/null 2>&1
    mokutil -x --kek > /dev/null 2>&1
    mokutil -x       > /dev/null 2>&1
    ls -1
    cd $old_dir

    cd $dest/dbx
    mokutil -x --dbx > /dev/null 2>&1
    ls -1
    cd $old_dir
}

verify_signed_installer()
{
    local sig="$1"

    keys_dir=$(mktemp -d)
    export_efi_certs $keys_dir

    # Signature is calculated the sha1sum of the installer image file
    image_digest=$(mktemp /var/tmp/installer.sign.XXXXXXXXXX)
    sha1sum $onie_installer | awk '{ print $1 }' > $image_digest

    for key in $(find $keys_dir/dbx -type f -name "*.der")
    do
        pem_key="${key%.*}.pem"
        [ -f $pem_key ] && rm -f $pem_key

        openssl x509 -in $key -inform der -out $pem_key -outform pem || {
            log_console_msg "Warning: Failed to create $pem_key from $key. Skipping $key."
            continue
        }
        openssl cms -verify -inform der -in $sig -content $image_digest -binary -CAfile $pem_key -nointern -certfile $pem_key > /dev/null 2>&1 || {
            log_failure_msg "Signed ONIE installer image is signed with a revoked key."
            rm -rf $image_digest $keys_dir
            return 1
        }
    done

    for key in $(find $keys_dir/db -type f -name "*.der")
    do
        pem_key="${key%.*}.pem"
        [ -f $pem_key ] && rm -f $pem_key

        openssl x509 -in $key -inform der -out $pem_key -outform pem || {
            log_console_msg "Warning: Failed to create $pem_key from $key. Skipping $key."
            continue
        }
        openssl cms -verify -inform der -in $sig -content $image_digest -binary -CAfile $pem_key -nointern -certfile $pem_key > /dev/null 2>&1
        if [ $? -eq 0 ]; then
            # check if this key is part of mokx
            mokutil --mokx --test-key $key > /dev/null 2>&1
            if [ $? -eq 1 ]; then
                log_failure_msg "Signed ONIE installer image is signed with a revoked key."
                break
            fi

            # Verificatin passed. Remove the temporary file and return
            log_console_msg "Signed ONIE installer image verification successfull"
            rm -rf $image_digest $keys_dir
            return 0
        fi
    done

    log_failure_msg "Signed ONIE Installer image verification failed"
    rm -rf $image_digest $keys_dir
    return 1
}

validate_input_image()
{
    local image="$1"

    ############################################################
    #              Signed ONIE Installer Image                 #
    ############################################################
    ###  ONIE Installer Image       (Signature Offset Bytes) ###
    ############################################################
    ###  Image Signature            (Signature Len Bytes)    ###
    ############################################################
    ###  Image Information Block    (48 Bytes)               ###
    ############################################################

    ############################################################
    #                Image Information Block                   #
    ############################################################
    ###  ONIE Image Identifier GUID (16 Bytes)               ###
    ############################################################
    ###  Signature  Identifier GUID (16 Bytes)               ###
    ############################################################
    ###  Signature Offset           (8 Bytes)                ###
    ############################################################
    ###  Signature Lenth            (8 Bytes)                ###
    ############################################################

    # Interpret the 'image information block' at the end of the image
    onie_image_id=$(tail -c $iib_size $image | head -c $guid_size | hexdump -v -e '4/1 "%02x" "-" 2/1 "%02x" "-"
                    2/1 "%02x" "-" 2/1 "%02x" "-" 6/1 "%02x"')
    signature_id=$(tail -c $(($iib_size-$guid_size)) $image | head -c $guid_size | hexdump -v -e '4/1 "%02x" "-"
                    2/1 "%02x" "-" 2/1 "%02x" "-" 2/1 "%02x" "-" 6/1 "%02x"')

    # Verify if the GUIDs match
    if [ "$onie_image_id" != "$ONIE_IMAGE_GUID" ] || [ "$signature_id" != "$CERT_TYPE_PKCS7_GUID" ]; then
        log_debug_msg "ONIE installer - Image Information Block not found"
        return 1
    fi

    return 0
}

split_signed_image()
{
    local image="$1"
    local signature="$2"

    # GUIDs matched, Split the installer image into its components
    signature_offset="0x$(tail -c $iib_len_offset $image | head -c $iib_len_size | hexdump -v -e '/1 "%02x"')"
    signature_offset_base10=$(printf "%u" $signature_offset)
    signature_len="0x$(tail -c $(( $iib_len_offset-$iib_len_size )) $image | head -c $iib_len_size | hexdump -v -e '/1 "%02x"')"
    signature_len_base10=$(printf "%u" $signature_len)

    log_console_msg "Extracting the image signature ... "
	tail -c $(( signature_len_base10 + iib_size )) $image | head -c $signature_len_base10 > $signature || {
        log_failure_msg "Splitting the signed ONIE installer image $image failed"
        rm -f $signature
        return 1
    }

    log_console_msg "Removing the image signature and the information block from the installer image ... "
    dd if=/dev/null of=$image bs=1 seek=$signature_offset_base10 >/dev/null 2>&1 || {
        log_failure_msg "Splitting the signed ONIE installer image $image failed"
        rm -f $signature
        return 1
    }

    return 0
}

check_signed_installer()
{
    # Check whether the image passed by 'onie-nos-install',
    # 'onie-self-update' or 'discover' is compatible with the
    # 'signed ONIE installable image' format
    local image_type="$1"
    local signature=$default_signature

    # Check if the SecureBoot is enable on the system
    check_secure_boot || {
        # SecureBoot is not enabled.
        # Allow traditional or signed ONIE installer image format.
        validate_input_image $onie_installer && {
            log_console_msg "Installer image $onie_installer is a signed ONIE installer"
            split_signed_image $onie_installer $signature || {
                log_failure_msg "Unable to strip the signature off $onie_installer"
                return 1
            }
            # Skip verifying the signature when secure boot is disabled
            rm -f $signature
        }
        return 0
    }

    log_console_msg "Secure Boot mode is enabled"
    # Check if the installer follows 'signed ONIE installable image' format
    validate_input_image $onie_installer || {
        log_failure_msg "Signature header not found in $onie_installer. Please use a valid signed ONIE installer"
        return 1
    }

    # Strip the signature of the signed ONIE installer
    split_signed_image $onie_installer $signature || {
        log_failure_msg "Unable to strip the signature off $onie_installer"
        return 1
    }

    # After the split, onie_installer contains only the unsigned installer data
    log_console_msg "A signed ONIE Installer Image detected. Installer: $onie_installer, Signature: $signature"
    log_console_msg "Verifying the signature using EFI keys ..."

    # Verify the signature with efi keys
    verify_signed_installer $signature && {
        log_console_msg "Signature verification of $onie_installer is successful"
        rm -f $signature
        return 0
    }
    log_failure_msg "Signature verification of $onie_installer failed"
    rm -f $signature
    return 1
}

run_installer()
{
    export onie_exec_url="$1"
    # escape any % characters for printing with printf
    print_exec_url=$(echo -n $onie_exec_url | sed -e 's/%/%%/g')
    log_console_msg "Executing installer: $print_exec_url"

    [ -r $onie_installer ] || {
        log_failure_msg "Unable to find installer: $onie_installer"
        return 1
    }

    image_type=$(get_image_type $onie_installer)
    check_installer $image_type || return 1

    if [ "$onie_secure_boot" = "yes" ]; then
        check_signed_installer $image_type || return 1
    fi

    chmod +x $onie_installer
    # Send installer execution output to stdout or /dev/console
    tee_path="$(realpath "/proc/$$/fd/1" 2>/dev/null)"
    if [ "$tee_path" = "/dev/null" ] || [ -z "$tee_path" ] ; then
        tee_path=/dev/console
    fi
    { $onie_installer $onie_installer_parms; echo "$?" > $install_result; } 2>&1 | \
        tee $tee_path | logger $log_stderr -t os-install -p ${syslog_onie}.info

    case $image_type in
        "$onie_image_type_nos")
            finish_nos_install "$(cat $install_result)" "$onie_exec_url" "$onie_installer" && return 0
            ;;
        "$onie_image_type_update")
            finish_update_install "$(cat $install_result)" "$onie_exec_url" "$onie_installer" && return 0
            ;;
        *)
            log_failure_msg "Unexpected image type: $image_type"
            ;;
    esac

    # installer should not return
    log_failure_msg "Unable to install image: $print_exec_url"
    return 1
}

# wget HTTP/FTP download helper
wget_run()
{
    type=$1
    URL="$2"

    wget_args="-T 3 -O $onie_installer"

    if [ "$onie_verbose" = "y" ] || [ "$from_cli" = "yes" ] ; then
        out_file="/proc/$$/fd/1"
    else
        wget_args="$wget_args -q"
        out_file="/dev/null"
    fi

    # add HTTP headers
    # Shell variable substituion
    bb_ver=$(busybox | head -1 | sed -e 's/ (.*//' -e 's/ /-/')
    os_ver=$(uname -r -s | sed -e 's/ /-/')
    user_agent="onie/1.0 (${os_ver}$onie_version; $bb_ver)"

    header_serial_num="ONIE-SERIAL-NUMBER: $onie_serial_num"
    header_eth_addr="ONIE-ETH-ADDR: $onie_eth_addr"
    header_vendor_id="ONIE-VENDOR-ID: $onie_vendor_id"
    header_machine="ONIE-MACHINE: $onie_machine"
    header_machine_rev="ONIE-MACHINE-REV: $onie_machine_rev"
    header_arch="ONIE-ARCH: $onie_arch"
    header_security_key="ONIE-SECURITY-KEY: $onie_sec_key"
    header_operation="ONIE-OPERATION: $onie_operation"
    header_version="ONIE-VERSION: $onie_version"

    # escape any % characters for printing with printf
    print_exec_url=$(echo -n $URL | sed -e 's/%/%%/g')
    log_debug_msg "Running wget with: $user_agent $wget_args $print_exec_url\n"
    log_info_msg "Attempting $print_exec_url ..."
    wget -U "$user_agent" $wget_args       \
        --header "$header_serial_num"   \
        --header "$header_eth_addr"     \
        --header "$header_vendor_id"    \
        --header "$header_machine"      \
        --header "$header_machine_rev"  \
        --header "$header_arch"         \
        --header "$header_security_key" \
        --header "$header_operation"    \
        --header "$header_version"      \
        "$URL" > $out_file 2>&1 && run_installer "$URL" && return 0

    return 1
}

# tftp_wrap -- A wrapper around busybox's tftp command that on error
# inspects the stderr output looking for a timeout.
tftp_timeout=no
tftp_wrap()
{
    tftp_timeout=no

    # capture tftp command output
    tftp_tmpout=$(mktemp)
    tftp $* > $tftp_tmpout 2>&1 
    rc=$?

    # on error check for timeout
    if [ "$rc" != "0" ] ; then
        grep -q timeout $tftp_tmpout && {
            tftp_timeout=yes
        }
    fi

    # return output to caller
    cat $tftp_tmpout
    rm -f $tftp_tmpout

    return $rc
}

# TFTP download helper
tftp_run()
{
    SERVER=$1
    BOOTFILE=$2

    URL="tftp://$SERVER/$BOOTFILE"
    # escape any % characters for printing with printf
    print_exec_url=$(echo -n $URL | sed -e 's/%/%%/g')
    log_debug_msg "Running tftp get with: server: $SERVER, bootfile: $BOOTFILE"
    log_info_msg "Attempting $print_exec_url ..."
    if [ "$onie_verbose" = "y" ] || [ "$from_cli" = "yes" ] ; then
        tftp_wrap -g -l $onie_installer -r $BOOTFILE $SERVER && run_installer "$URL" && return 0
    else
        tftp_wrap -g -l $onie_installer -r $BOOTFILE $SERVER > /dev/null 2>&1 && run_installer "$URL" && return 0
    fi

    return 1
}

# Try possible URL handlers
# URL could be:
#   http://
#   ftp://
#   file://
#   tftp://
url_run()
{
    URL="$1"
    quiet=$2
    url_type=${URL%%:*}
    url_path=${URL##*://}
    rm -f $onie_installer
    case $url_type in
        http | https | ftp)
            wget_run $url_type "$URL" && return 0
            ;;
        tftp)
            server=${url_path%%/*}
            path=${url_path#*/}
            tftp_run $server $path && return 0
            ;;
        file)
            cp $url_path $onie_installer && run_installer "$URL" && return 0
            ;;
        *)
            # First see if "$URL" refers a local file
            if [ -r "$URL" ] ; then
                cp $URL $onie_installer && run_installer "$URL" && return 0
                return 1
            fi
            [ -n "$quiet" ] || log_failure_msg "Unknown URL type: $URL"
            ;;
    esac

    rm -f $onie_installer
    return 1
}

get_onie_neighs()
{
    while [ ${#onie_neighs} -gt 0 ] ; do
        local n=${onie_neighs%%,*}
        onie_neighs=${onie_neighs#*,}
        echo $n | sed -e 's/-/%/g'
    done
}

ulist()
{
    local list=$(echo "$1" | sed -e '/#/d')
    # make list items unique, while preserving list order
    { local cnt=0; for s in $list ; do printf "%d\t%s\n" $cnt $s ; cnt=$(( $cnt + 1 )) ; done ; } | \
        sort -u -k2 | sort -n | cut -f2-
}

# Try various HTTP URLs
http_download()
{
    # Build list of HTTP servers to try
    local http_servers=$(ulist "\
$onie_server_name
# HTTP server IP only (DHCP opt 72)
$onie_disco_wwwsrv
# BOOTP next-server IP
$onie_disco_siaddr
# DHCP server IP (DHCP opt 54)
$onie_disco_serverid
# TFTP server IP (DHCP opt 150)
$onie_disco_tftpsiaddr
# DHCP TFTP server name (DHCP opt 66)
# Requires DNS
$onie_disco_tftp
# Add link local neighbors
$(get_onie_neighs)
")

    for server in $http_servers ; do
        # Check if server appears to be alive
        nc -w 10 $server 80 -e /bin/true > /dev/null 2>&1 && {
            # Try list of default file names
            for f in $(get_default_filenames) ; do
                url_run "http://$server/$f" && return 0
            done
        }
    done

    # Try bootfile as a URL, supress warnings
    if [ -n "$onie_disco_bootfile" ] ; then
        url_run "$onie_disco_bootfile" quiet && return 0
    fi

    return 1
}

tftp_download()
{
    local tftp_servers=$(ulist "\
$onie_server_name
# BOOTP next-server IP
$onie_disco_siaddr
# TFTP server name (DHCP opt 66)
# Requires DNS
$onie_disco_tftp
# TFTP server IP (DHCP opt 150)
$onie_disco_tftpsiaddr
# DHCP server IP (DHCP opt 54)
$onie_disco_serverid
")

    # Busybox sets "boot_file" for the BOOTP boot file and sets
    # "bootfile" (no underscore) for DHCP option 67.
    local tftp_bootfiles=$(ulist "\
$onie_disco_bootfile
$onie_disco_boot_file
")

    for server in $tftp_servers ; do
        for f in $tftp_bootfiles ; do
            url_run "tftp://$server/$f" && return 0
        done
    done

    return 1
}

waterfall()
{
    # Build list of waterfall paths

    wf_paths=
    # First is based on MAC address
    [ -n "$onie_eth_addr" ] && wf_paths="$(echo $onie_eth_addr | sed -e 's/:/-/g')/$onie_default_filename"

    if [ -n "$onie_disco_ip" ] ; then
        # Next 8 are based on IP address in HEX:
        tmp=$(echo $onie_disco_ip | sed -e 's/\./ /g')
        cmd="printf %02X%02X%02X%02X $tmp"
        wf_ip=$(eval $cmd)
        len=8
        while [ $len -gt 0 ] ; do
            wf_paths="$wf_paths $(echo $wf_ip | head -c $len)/$onie_default_filename"
            len=$(( $len - 1 ))
        done
    fi

    # Next is root of tftp server -- try all default filenames
    wf_paths="$wf_paths $(get_default_filenames)"

    # TFTP waterfall
    local tftp_servers=$(ulist "$onie_server_name $onie_disco_siaddr $onie_disco_tftp $onie_disco_tftpsiaddr")
    for s in $tftp_servers ; do
        for p in $wf_paths ; do
            url_run "tftp://$s/$p" && return 0
            if [ "$tftp_timeout" = "yes" ] ; then
                # Stop TFTP waterfall on a timeout.
                break;
            fi
        done
    done

    return 1
}

local_fs_run()
{
    mp=$(mktemp -d)
    while [ ${#onie_local_parts} -gt 0 ] ; do
        p=${onie_local_parts%%,*}
        mountopts=""
        beginswith "ubi:" $p && mountopts="-t ubifs"
        onie_local_parts=${onie_local_parts#*,}
        mount $mountopts $p $mp > /dev/null 2>&1 && {
            for f in $(get_default_filenames) ; do
                if [ -r $mp/$f ] ; then
                    # copy to /tmp, which is a tmpfs -- installer needs to
                    # run with everything unmounted.
                    tmp_copy=$(mktemp -p /tmp)
                    cp $mp/$f $tmp_copy || {
                        log_failure_msg "local_fs_run():$p Unable to copy $mp/$f to tmpfs"
                        rm -f $tmp_copy
                        return 1
                    }
                    sync ; sync
                    umount $mp
                    ln -sf $tmp_copy $onie_installer || {
                        log_failure_msg "local_fs_run():$p Unable to make symlink to $onie_installer in tmpfs"
                        rm -f $tmp_copy
                        return 1
                    }
                    run_installer "file:/$p/$f" && return 0
                    rm -f $tmp_copy $onie_installer
                    # re-mount it to look for more files
                    mount $mountopts $p $mp > /dev/null 2>&1
                fi
            done
            umount $p
        }
    done
    rm -rf $mp

    return 1
}

firmware_update_run()
{
    local fw_rc=1
    for image in $(ls $onie_update_pending_dir) ; do
        if url_run "$onie_update_pending_dir/$image" ; then
            fw_rc=0
        else
            fw_rc=1
            break
        fi
    done

    if [ $fw_rc -eq 0 ] ; then
        # Firmware update(s) found and processed.
        if [ -x /tmp/reboot-cmd ] ; then
            log_console_msg "Calling update supplied reboot-cmd..."
            /tmp/reboot-cmd
            sleep 10
        else
            log_console_msg "Rebooting..."
            reboot && return 0
        fi
    fi
    
    return 1
}

##
## Script starts here
##

parm_file="$1"
[ -r $parm_file ] || {
    log_failure_msg "Unable to read parameter file: $parm_file"
    log_console_msg "FATAL: Unable to read parameter file: $parm_file"
    exit 1
}
parms="$(cat $parm_file)"

import_parms "$parms"
rm -f $onie_installer

[ -z "$onie_eth_addr" ] && onie_eth_addr="$(onie-sysinfo -e)"
[ -z "$onie_serial_num" ] && onie_serial_num="$(onie-sysinfo -s)"

from_cli=no
onie_installer_parms=

# Try static installer URL from CLI
if [ -n "$onie_cli_static_url" ] ; then
    from_cli=yes
    # also send to stdout of current process
    tee_log_file=/proc/$$/fd/1
    onie_installer_parms="$onie_cli_static_parms"
    url_run "$onie_cli_static_url" && exit 0
    # stop here if it didn't work
    exit 1
fi

# Try static updater URL from CLI
if [ -n "$onie_cli_static_update_url" ] ; then
    from_cli=yes
    # also send to stdout of current process
    tee_log_file=/proc/$$/fd/1
    onie_installer_parms="$onie_cli_static_update_parms"
    url_run "$onie_cli_static_update_url" && exit 0
    # stop here if it didn't work
    exit 1
fi

# Next try static URL from kernel command line
if [ -n "$onie_static_url" ] ; then
    url_run "$onie_static_url" && exit 0
fi

# Next look for pending firmware updates
if [ -d "$onie_update_pending_dir" ] ; then
    firmware_update_run && exit 0
fi

# Next try locally attached filesystems
if [ -n "$onie_local_parts" ] ; then
    local_fs_run && exit 0
fi

# Next try exactly discovered URLs
if [ -n "$onie_disco_onie_url" ] ; then
    url_run "$onie_disco_onie_url" && exit 0
fi

if [ -n "$onie_disco_url" ] ; then
    url_run "$onie_disco_url" && exit 0
fi

# Try HTTP discovery methods next
http_download && {
    echo "http success, exiting..."
    exit 0
}

# Try TFTP discovery methods next
tftp_download && {
    echo "tftp success, exiting..."
    exit 0
}

# Finally try HTTP/TFTP waterfall methods
waterfall && {
    echo "waterfall success, exiting..."
    exit 0
}

exit 1

# Local Variables:
# mode: shell-script
# eval: (sh-set-shell "/bin/sh" t nil)
# End:
